#include <OneWire.h> // Required for ds18b20 temparature sensor 
#include <DS3231.h>
#include <LCD5110_Basic.h>
#include <RCSwitch.h>

RCSwitch mySwitch = RCSwitch();

LCD5110 myGLCD(8,9,10,11,12);
extern uint8_t SmallFont[];
extern uint8_t MediumNumbers[];
extern uint8_t BigNumbers[];

// Pin Configuration 
#define TEMPERATURE_PIN   4
#define RELAY_PIN         5
#define BUTTON_PIN        7
// Initial desired temperature
#define DESIRED_TEMP      22
// Error Code
#define TEMP_ERR          -255
// Working modes
#define TEMPERATURE_MODE  1
#define KOMBI_MODE        2
#define BUTTON_MODE       3
// Difference should be 1 celcius.
#define TEMP_INTERVAL     1

OneWire  ds(TEMPERATURE_PIN);  // Normally 4.7k resistor is neccessary but i am using ready to use sensor card.
DS3231  rtc(SDA, SCL);

// Global Variables
int working_mode = TEMPERATURE_MODE;
int desired_temperature = DESIRED_TEMP;
int temperature_val = DESIRED_TEMP;
const int GasSensorIn = A0;
int  button_state = LOW;  
char *controller;

const unsigned char temperatureIcon [] PROGMEM = {
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x01,
0x01, 0x01, 0x01, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0xFF, 0x00, 0xF8, 0xF8, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0xF0, 0xF8, 0x0C, 0xC6, 0xE3, 0xF0, 0xFF, 0xFF, 0xF0, 0xE3, 0xC6, 0x0C, 0xF8, 0xF0,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x0F, 0x18, 0x31, 0x23, 0x67, 0x67, 0x67, 0x67, 0x23,
0x31, 0x18, 0x0F, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
};

// the setup function runs once when you press reset or power the board
void setup() {
  Serial.begin(115200);
  pinMode(RELAY_PIN, OUTPUT);
  pinMode(BUTTON_PIN, INPUT_PULLUP);
  // Temporary debug
  pinMode(13, OUTPUT);

  rtc.begin();
  myGLCD.InitLCD();
  // The following lines can be uncommented to set the date and time
  //rtc.setDOW(SATURDAY);     // Set Day-of-Week to SUNDAY
  //rtc.setTime(12, 42, 0);     // Set the time to 12:00:00 (24hr format)
  //rtc.setDate(4, 11, 2017);   // Set the date to January 1st, 2014

// Transmitter is connected to Arduino Pin #10  
//  mySwitch.enableTransmit(12);
}

// the loop function runs over and over again forever
void loop() {
/*  digitalWrite(13,HIGH);
  //mySwitch.send("10000100011000000000010100");
  mySwitch.send("111111111111111");
  delay(2000); 
  digitalWrite(13,LOW);
  delay(2000);
  mySwitch.send("1000000");
   return;
*/

   // read the state of the pushbutton value:
   int tmp_button_state = digitalRead(BUTTON_PIN);

   if ( tmp_button_state != button_state )
   {
        // check if the pushbutton is pressed. If it is, the buttonState is HIGH:
        if (tmp_button_state == HIGH) {
          stop_heater();
        } 
        else {
          start_heater();
       }
       button_state = tmp_button_state;
       working_mode = BUTTON_MODE;
       delay(1000);

       return;
   }

  // Gas Sensor Send
  {
    int gas_sensor = analogRead(GasSensorIn);        
   
    Serial.println('G');                       
    Serial.println(gas_sensor); 
  }  
  
  // Read temperature sensor
  temperature_val = Read_Temperature_Celsius();
  // Sometimes sensor returns error, Do Nothing
  if ( temperature_val == TEMP_ERR )
  {
      return;
  }
  
  myGLCD.drawBitmap(0, 0, temperatureIcon, 84, 48); 
  myGLCD.setFont(BigNumbers);
  myGLCD.printNumI(temperature_val, RIGHT, 24);

  // Kombi On/Off is not triggered from mobile app
  if ( working_mode == TEMPERATURE_MODE )
  {
        Serial.println("temperature mode");
        if ( (temperature_val <= (desired_temperature - TEMP_INTERVAL)))
        {
            start_heater();
        }
        else if ( (temperature_val >= (desired_temperature + TEMP_INTERVAL)))
        {
            stop_heater();
        }
        else
        {
            // DO nothing!!! Keep last state.
        }
  }

  // Send temperature value to the mobile app
  Serial.println('T');
  Serial.println(temperature_val);

  // Read serial data that is sent by mobile app
  if(Serial.available() > 0)
  {
    char cmd = Serial.read();

    // Kombi  ON/OFF
    if(cmd == 'K')
    {
      int state = Serial.parseInt();
      if(state == 1)
      {
        start_heater();
        digitalWrite(13,1);
      }
      else
      {
        digitalWrite(13,0);
        stop_heater();
      }

      working_mode = KOMBI_MODE;
    }
    // Desired temperature
    else if(cmd == 'D')
    {
      desired_temperature = Serial.parseInt();
      
      working_mode = TEMPERATURE_MODE;
    }
  }

  delay(1000);
}

void stop_heater()
{
  Serial.println('Y');
  digitalWrite(RELAY_PIN, HIGH);
  delay(250);
}

void start_heater()
{
  Serial.println('X');
  digitalWrite(RELAY_PIN, LOW);
  delay(250);
}

float Read_Temperature_Celsius()
{
  byte index;
  byte present = 0;
  byte type_s;
  byte data[12];
  byte addr[8];
  float celsius, fahrenheit;

  if ( !ds.search(addr)) {
//    Serial.println("No more addresses.");
 //   Serial.println();
    ds.reset_search();
    delay(250);
    return TEMP_ERR;
  }
  
//  Serial.print("ROM =");
  for( index = 0; index < 8; index++) {
//    Serial.write(' ');
//    Serial.print(addr[index], HEX);
  }

  if (OneWire::crc8(addr, 7) != addr[7]) {
//      Serial.println("CRC is not valid!");
      return TEMP_ERR;
  }
  Serial.println();

// the first ROM byte indicates which chip
  switch (addr[0]) {
    case 0x10:
 //     Serial.println("  Chip = DS18S20");  // or old DS1820
      type_s = 1;
      break;
    case 0x28:
 //     Serial.println("  Chip = DS18B20");
      type_s = 0;
      break;
    case 0x22:
 //     Serial.println("  Chip = DS1822");
      type_s = 0;
      break;
    default:
//      Serial.println("Device is not a DS18x20 family device.");
      return TEMP_ERR;
  } 

  ds.reset();
  ds.select(addr);
  ds.write(0x44, 1);        // start conversion, with parasite power on at the end
  
  delay(1000);     // maybe 750ms is enough, maybe not
  // we might do a ds.depower() here, but the reset will take care of it.
  
  present = ds.reset();
  ds.select(addr);    
  ds.write(0xBE);         // Read Scratchpad

//  Serial.print("  Data = ");
//  Serial.print(present, HEX);
//  Serial.print(" ");
  for ( index = 0; index < 9; index++) {           // we need 9 bytes
    data[index] = ds.read();
//    Serial.print(data[index], HEX);
//    Serial.print(" ");
  }
//  Serial.print(" CRC=");
//  Serial.print(OneWire::crc8(data, 8), HEX);
//  Serial.println();

  // Convert the data to actual temperature
  // because the result is a 16 bit signed integer, it should
  // be stored to an "int16_t" type, which is always 16 bits
  // even when compiled on a 32 bit processor.
  int16_t raw = (data[1] << 8) | data[0];
  if (type_s) {
    raw = raw << 3; // 9 bit resolution default
    if (data[7] == 0x10) {
      // "count remain" gives full 12 bit resolution
      raw = (raw & 0xFFF0) + 12 - data[6];
    }
  } else {
    byte cfg = (data[4] & 0x60);
    // at lower res, the low bits are undefined, so let's zero them
    if (cfg == 0x00) raw = raw & ~7;  // 9 bit resolution, 93.75 ms
    else if (cfg == 0x20) raw = raw & ~3; // 10 bit res, 187.5 ms
    else if (cfg == 0x40) raw = raw & ~1; // 11 bit res, 375 ms
    //// default is 12 bit resolution, 750 ms conversion time
  }
  celsius = (float)raw / 16.0;
  fahrenheit = celsius * 1.8 + 32.0;
/*  Serial.print("  Temperature = ");
  Serial.print(celsius);
  Serial.print(" Celsius, ");
  Serial.print(fahrenheit);
  Serial.println(" Fahrenheit");*/

  return celsius;
}
